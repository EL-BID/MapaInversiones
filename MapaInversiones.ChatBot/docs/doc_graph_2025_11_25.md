# DocumentaciÃ³n Completa del LangGraph - Mapa Inversiones Chatbot

**Fecha de actualizaciÃ³n**: 2025-11-29  
**Generado por**: Agente de DocumentaciÃ³n AutomÃ¡tica  
**VersiÃ³n del sistema**: ChatBot_v2

---

## ğŸ“Š Arquitectura General

El grafo es una mÃ¡quina de estados implementada con **LangGraph** que procesa consultas de usuarios sobre proyectos de inversiÃ³n pÃºblica. Orquesta mÃºltiples nodos (funciones) que se ejecutan condicionalmente segÃºn el estado compartido (`AgentState`).

### Principios de DiseÃ±o

1. **ModeraciÃ³n temprana**: Seguridad y clasificaciÃ³n antes de procesamiento costoso
2. **Transparencia ciudadana**: Explicar limitaciones y decisiones al usuario
3. **Reintentos inteligentes**: MÃºltiples estrategias de correcciÃ³n ante errores
4. **OptimizaciÃ³n de recursos**: Cache, lazy loading, filtrado de schema

---

## ğŸ”„ Flujo Completo: AnÃ¡lisis Paso a Paso

### ETAPA 1: Ingreso y Reescritura âœï¸

#### `START â†’ generate_complete_question_v2`

**PropÃ³sito**: Convierte la pregunta del usuario en una consulta completa y autocontenida, usando el historial de conversaciÃ³n.

**Archivo**: `nodes_prefetch.py`  
**Prompt**: `generate_complete_question_prompt_v2` (`prompts_prefetch.py`)

**Proceso**:
- Analiza el historial de mensajes
- Normaliza referencias temporales ("este aÃ±o" â†’ 2024)
- Resuelve pronombres y referencias ("allÃ­" â†’ "RepÃºblica Dominicana")
- Maneja cambios de tema

**Estado actualizado**:
- `state["complete_user_question"]`

**Ejemplo**:
```
Usuario: "Â¿CuÃ¡ntos proyectos de salud?"
â†’ "Â¿CuÃ¡ntos proyectos de salud hay en RepÃºblica Dominicana?"

Usuario: "Â¿Y en educaciÃ³n?"
â†’ "Â¿CuÃ¡ntos proyectos de educaciÃ³n hay en RepÃºblica Dominicana?"
```

---

### ETAPA 2: ClasificaciÃ³n y ModeraciÃ³n ğŸ›¡ï¸

#### `generate_complete_question_v2 â†’ inbox_classifier`

**PropÃ³sito**: Nodo unificado que realiza moderaciÃ³n de contenido y clasificaciÃ³n de intenciÃ³n.

**Archivo**: `nodes_prefetch.py`  
**Prompt**: `inbox_classifier_prompt` (`prompts_prefetch.py`)

**Funcionalidades**:

1. **ModeraciÃ³n**:
   - Detecta PII (informaciÃ³n personal identificable)
   - Identifica contenido prohibido (violencia, odio, etc.)
   - Maneja abuso/spam

2. **ClasificaciÃ³n de intenciÃ³n**:
   - Relevancia al dominio
   - Tipo de interacciÃ³n (social, tÃ©cnica, consulta de datos)
   - Consultas de definiciones/conceptos

**Flags establecidos**:
```python
is_relevant: "yes" | "no" | "unknown"
is_social_interaction: bool  # saludos, despedidas
is_support_request: bool     # ayuda tÃ©cnica
is_definitions_lookup: bool  # "Â¿QuÃ© es X?"
recommended_action: "allow" | "reprompt" | "block"
```

**Fallback**: Si falla el parsing JSON, asume `recommended_action = "allow"` por seguridad.

---

#### `inbox_classifier â†’ route_after_inbox`

**Archivo**: `edges.py`  
**FunciÃ³n**: `route_after_inbox()`

**Rutas posibles** (en orden de prioridad):

##### Camino A: ModeraciÃ³n ğŸš¨
**CondiciÃ³n**: `recommended_action in ["reprompt", "block"]`  
**Ruta**: `moderation_reprompt` â†’ `prefetch_exit` â†’ **END**  
**Respuesta**: Mensaje de seguridad predefinido

##### Camino B: BÃºsqueda de Definiciones ğŸ“š
**CondiciÃ³n**: `is_definitions_lookup == true`  
**Ruta**: `definitions_lookup` â†’ `prefetch_exit` â†’ **END**

**Proceso**:
- Lee archivo markdown versionado: `data/concepts_definitions_v*.md`
- Usa prompt `definitions_lookup_prompt`
- Extrae definiciÃ³n exacta (NO alucina)
- Traduce tÃ©rminos tÃ©cnicos de DB a lenguaje ciudadano

**Respuesta**: JSON con definiciÃ³n, nivel de confianza, y fuente.

##### Camino C: Cache Hit âš¡
**CondiciÃ³n**: `is_cache_hit and is_recent_cache_hit`  
**Ruta**: Directo a `process_user_response` (salta generaciÃ³n SQL)  
**Ventaja**: Respuesta instantÃ¡nea reutilizando resultados previos

##### Camino D: Saludos/Social ğŸ‘‹
**CondiciÃ³n**: `is_social_interaction == true`  
**Ruta**: `send_greeting` â†’ `prefetch_exit` â†’ **END**  
**Respuesta**: Saludo amigable con ayuda contextual

##### Camino E: Consulta Irrelevante âŒ
**CondiciÃ³n**: `is_relevant == "no"`  
**Ruta**: `handle_irrelevant_question` â†’ `prefetch_exit` â†’ **END**  
**Respuesta**: Explica que estÃ¡ fuera del dominio (inversiÃ³n pÃºblica)

##### Camino F: Soporte TÃ©cnico ğŸ†˜
**CondiciÃ³n**: `is_support_request == true`  
**Ruta**: `send_support_response` â†’ `prefetch_exit` â†’ **END**  
**Respuesta**: InformaciÃ³n de contacto, guÃ­as de uso

##### Camino G: Flujo Normal (Consulta SQL) âœ…
**CondiciÃ³n**: `is_relevant == "yes"`  
**Ruta**: `generate_question_summary` â†’ continÃºa a ETAPA 3

---

### ETAPA 3: Resumen y Contexto ğŸ”

#### `route_after_inbox â†’ generate_question_summary`

**PropÃ³sito**: Genera un tÃ­tulo corto (8-13 palabras) para el sidebar del frontend.

**Archivo**: `nodes_postfetch.py`  
**Prompt**: `generate_question_summary_prompt` (`prompts_postfetch.py`)

**Estado actualizado**: `state["question_summary"]`

---

#### `generate_question_summary â†’ retrieve_documents`

**PropÃ³sito**: Recupera documentos relevantes para enriquecer el contexto de generaciÃ³n SQL.

**Archivo**: `nodes_prefetch.py`

**Proceso**:
1. **BÃºsqueda vectorial**: Usa embeddings para encontrar documentos similares
2. **Re-ranking**: Aplica `perform_rerank_search` para mejorar precisiÃ³n
3. **Few-shot recovery**: Recupera ejemplos de NL2SQL previos
4. **Truncado**: Limita tokens usando `truncate_text` para evitar overflow

**TecnologÃ­as**:
- Embeddings: OpenAI `text-embedding-3-small`
- Vector DB: (implementaciÃ³n en `modules/utils/`)

**Estado actualizado**: `state["documents"]`

---

### ETAPA 4: AnÃ¡lisis Profundo ğŸ§ 

#### `retrieve_documents â†’ llm_analyzer`

**PropÃ³sito**: Analiza la pregunta en profundidad para extraer metadatos estructurados.

**Archivo**: `nodes_prefetch.py`  
**Prompt**: `llm_analyzer_prompt` (`prompts_prefetch.py`)

**Extrae**:
- **Filtros**: `[{column, operator, value, confidence}]`
- **Tablas necesarias**: `[stg_mapainv_proyectosaprobadosinv, ...]`
- **Complejidad**: HeurÃ­stica inicial
- **Incertidumbres**: Dudas sobre la intenciÃ³n del usuario
- **Advertencias**: Limitaciones de datos

**Estado actualizado**: `state["analysis"]`

**Ejemplo de salida**:
```python
{
  "filters": [
    {"column": "nombresector_proyecto", "value": "EDUCACIÃ“N", "confidence": 0.95},
    {"column": "anio_fechainicio_proyecto", "value": "2024", "confidence": 0.8}
  ],
  "tables": ["stg_mapainv_proyectosaprobadosinv"],
  "uncertainties": {
    "reason": None,
    "actions": []
  }
}
```

---

#### `llm_analyzer â†’ route_after_analyzer`

**Archivo**: `edges.py`  
**FunciÃ³n**: `route_after_analyzer()`

**Decisiones**:

##### OpciÃ³n 1: Zona Gris âš ï¸
**CondiciÃ³n**: Analyzer detecta problema crÃ­tico  
**Ejemplos**:
- Atributo solicitado no existe en schema
- MÃ©trica no disponible en dataset
- AmbigÃ¼edad irresoluble

**Ruta**: `handle_gray_zone` â†’ `route_after_gray_zone`

**Proceso**:
- Consulta reglas en `gray_zone_rules.py`
- Infiere razÃ³n: `MISSING_DIMENSION`, `UNSUPPORTED_METRIC`, etc.
- Construye mensaje explicativo
- Ofrece alternativas si existen

**Sub-rutas desde `route_after_gray_zone`**:
- Si hay alternativas: `request_clarification` â†’ **END**
- Si no hay soluciÃ³n: `prefetch_exit` â†’ **END**

##### OpciÃ³n 2: Necesita AclaraciÃ³n â“
**CondiciÃ³n**: Incertidumbres de baja confianza detectadas  
**Ruta**: `request_clarification` â†’ **END**

**Archivo**: `nodes.py`  
**FunciÃ³n**: `request_clarification()`

**Construye opciones**:
```python
{
  "options": [
    {"label": "Sector EducaciÃ³n", "value": "EDUCACIÃ“N", "target": "sector"},
    {"label": "Sector Salud", "value": "SALUD", "target": "sector"}
  ],
  "message": "Â¿A quÃ© sector te refieres?",
  "turn": 1,
  "max_turns": 2
}
```

##### OpciÃ³n 3: Continuar âœ…
**CondiciÃ³n**: AnÃ¡lisis claro, sin bloqueos  
**Ruta**: `classify_question_complexity`

---

### ETAPA 5: ClasificaciÃ³n de Complejidad ğŸ¯

#### `route_after_analyzer â†’ classify_question_complexity`

**PropÃ³sito**: HeurÃ­stica simple para elegir estrategia de generaciÃ³n SQL.

**Archivo**: `nodes_fetch.py`

**Criterios para COMPLEJA**:
- MÃºltiples tablas (joins)
- Agregaciones complejas (GROUP BY con mÃºltiples dimensiones)
- Subconsultas
- Ordenamiento + lÃ­mite + paginaciÃ³n

**Criterios para SIMPLE**:
- Tabla Ãºnica
- Filtros directos
- AgregaciÃ³n simple o ninguna

**Estado actualizado**: `state["is_complex_query"]`

---

#### `classify_question_complexity â†’ llm_analyzer_2`

**PropÃ³sito**: Genera few-shots personalizados basados en el anÃ¡lisis.

**Archivo**: `nodes_prefetch.py`  
**Prompt**: `llm_analyzer_2_prompt` (`prompts_prefetch.py`)

**Proceso**:
- Usa filtros corregidos del analyzer
- Incorpora valores de catÃ¡logo (fuzzy-matched)
- Documenta optimizaciones (join pushdown, etc.)
- Crea ejemplos NL2SQL especÃ­ficos para esta consulta

**Estado actualizado**: `state["custom_few_shots"]`

---

### ETAPA 6: GeneraciÃ³n de SQL ğŸ’¾

#### `llm_analyzer_2 â†’ route_after_retrieve_documents`

**Archivo**: `edges.py`  
**FunciÃ³n**: `route_after_retrieve_documents()`

**Control global**: `USE_COMPLEXITY_ROUTING` (settings)

**Rutas**:

---

##### Camino SIMPLE: One-Shot SQL ğŸ¯

**Ruta**: `generate_sql_query` â†’ `fetch_data`

**Archivo**: `nodes_fetch.py`  
**FunciÃ³n**: `generate_sql_query()`  
**Prompt base**: `_GENERATE_SQL_QUERY_PROMPT_BASE` (`prompts_fetch.py`)

**Proceso interno**:

1. **Filtrado de Schema**:
   - Solo incluye tablas del analyzer en el schema JSON
   - Reduce tokens del prompt dramÃ¡ticamente

2. **AplicaciÃ³n de Filtros Refinados**:
   - FunciÃ³n: `_apply_refined_filters_to_sql()`
   - Usa tokens primarios con `EXISTS` + `regexp_split_to_table`
   - Ejemplo:
     ```sql
     EXISTS (
       SELECT 1 FROM regexp_split_to_table(process_text(nombre_proyecto), '[^[:alnum:]]+') AS w(token)
       WHERE w.token = process_text('metro')
     )
     ```

3. **AplicaciÃ³n de Filtros de CatÃ¡logo**:
   - FunciÃ³n: `_apply_catalog_equals_to_sql()`
   - Usa igualdad exacta para dimensiones conocidas
   - Ejemplo: `UPPER(TRIM(nombresector_proyecto)) = UPPER(TRIM('EDUCACIÃ“N'))`

4. **ExpansiÃ³n de Keywords**:
   - Inyecta instrucciones de bÃºsqueda temÃ¡tica en el prompt
   - Estrategia configurable: `EXISTS` vs `ILIKE`

5. **OptimizaciÃ³n de Unique Lookup**:
   - Para queries tipo "proyecto con id X"
   - Genera SQL determinÃ­stico sin LLM
   - Bypass completo de generaciÃ³n

6. **Filtro de PaÃ­s**:
   - FunciÃ³n: `_ensure_country_filter()`
   - Garantiza `pais_iso3 = 'DOM'` (o el paÃ­s actual)

**Prompt modular**:
- `MODULAR_TERRITORIAL_GUIDELINES`: Join optimization para territorios
- `MODULAR_FUNDING_GUIDELINES`: Join optimization para fuentes de financiamiento

**Estado actualizado**: `state["sql_query"]`

---

##### Camino COMPLEJO: Multi-Candidatos ğŸ”€

**Ruta**: `generate_sql_candidates` â†’ `select_best_sql_candidate` â†’ `choose_sql_with_llm` â†’ `fetch_data`

**1. `generate_sql_candidates`**

**Archivo**: `nodes_fetch.py`

**Proceso**:
- Genera 3-5 variantes de SQL
- Aplica todas las optimizaciones del camino simple
- VarÃ­a en estrategias de join, ordenamiento, agregaciÃ³n

**Estado actualizado**: `state["sql_candidates"]`

**2. `select_best_sql_candidate`**

**Archivo**: `nodes_fetch.py`  
**FunciÃ³n**: `_score_sql_candidates()` (`helpers_sql.py`)

**Scoring**:
- Ejecuta `EXPLAIN` en cada candidato
- Asigna puntos:
  - `SCORE_OK_ROWS = 90`: Si tiene â‰¥1 fila
  - `SCORE_ZERO_ROWS = 85`: Si tiene 0 filas
  - `SCORE_EXPLAIN_FAILED = -1`: Si EXPLAIN falla
- Penaliza por costo estimado: `-min(cost / 5, 20)`
- Penaliza joins territoriales innecesarios: `-150`

**Proceso**:
- Ordena por score descendente
- Marca el mejor con `is_decided = True` si score > umbral

**Estado actualizado**: `state["sql_candidates"]` (ordenados)

**3. `route_after_select_best`**

**Archivo**: `edges.py`

**DecisiÃ³n**:
- Si `best_candidate["is_decided"]`: Directo a `fetch_data`
- Si no: Va a `choose_sql_with_llm`

**4. `choose_sql_with_llm`**

**Archivo**: `nodes_fetch.py`  
**Prompt**: `choose_sql_prompt` (`prompts_fetch.py`)

**Criterios de selecciÃ³n**:
- EjecuciÃ³n exitosa
- Relevancia a la pregunta
- Simplicidad
- Estrategia correcta de keywords

**Estado actualizado**: `state["sql_query"]` (elegida)

---

### ETAPA 7: EjecuciÃ³n y Manejo de Errores âš™ï¸

#### `fetch_data`

**Archivo**: `nodes_fetch.py`  
**FunciÃ³n interna**: `execute_sql_query()` (`modules/utils/db_utils.py`)

**Proceso**:
1. **PreparaciÃ³n**: `prepare_sql_for_execution()`
2. **EjecuciÃ³n**: SQLAlchemy con timeout
3. **SerializaciÃ³n**: Convierte rows a JSON

**Casos de salida**:
- **Ã‰xito**: JSON en `state["sql_results"]`, rowcount en `state["sql_rowcount"]`
- **Error PostgreSQL**: `state["pg_error"]` con mensaje completo
- **Zero rows**: `state["zero_rows_after_fallback"] = True`

---

#### `fetch_data â†’ handle_fetch_data_outcome`

**Archivo**: `edges.py`  
**FunciÃ³n**: `handle_fetch_data_outcome()`

**Rutas posibles**:

##### Caso 1: Error de SQL ğŸ”´

**CondiciÃ³n**: `state.get("pg_error")`

**Ruta**: `regenerate_query` â†’ `fetch_data` (loop)

**LÃ­mite de reintentos**: 2 (`max_sql_retries`)

---

##### Caso 2: Zero Rows (necesita estrategia) ğŸ”

**CondiciÃ³n**: `rowcount == 0 and not used_fallback`

**Estrategias**:

1. **Keyword Regeneration**:
   - FunciÃ³n: `_build_keyword_regeneration_sql_from_theme()`
   - Extrae keywords de filtros originales
   - Construye SQL con `EXISTS` para bÃºsqueda mÃ¡s laxa
   - Ejemplo: "Metro de Santo Domingo" â†’ tokens: ["metro", "santo", "domingo"]

2. **Post-Fetch Clarification**:
   - FunciÃ³n: `_prepare_post_fetch_clarification()`
   - Ofrece sinÃ³nimos, sectores alternativos, entidades
   - Construye payload con opciones interactivas

**Rutas**:
- Si keyword regeneration exitoso: `fetch_data` (reintento)
- Si falla: `request_clarification` â†’ **END**
- O: `handle_gray_zone` â†’ `route_after_gray_zone`

---

##### Caso 3: Ã‰xito âœ…

**CondiciÃ³n**: `rowcount > 0`

**Ruta**: `process_user_response`

---

#### `regenerate_query`

**Archivo**: `nodes_fetch.py`  
**Prompt base**: `_REGENERATE_QUERY_PROMPT_BASE` (`prompts_fetch.py`)

**Inputs al prompt**:
- Error de PostgreSQL (sintaxis, semÃ¡ntica)
- Pregunta original
- Schema filtrado
- Historial de SQLs fallidas
- Filtros faltantes detectados

**Estrategias especiales**:

1. **Literal Regeneration**:
   - Para errores de sintaxis o lÃ³gica
   - Analiza el error y corrige

2. **Keyword Regeneration**:
   - Para zero rows con filtros textuales muy estrictos
   - Prompt: `_KEYWORD_REGENERATE_PROMPT` (`prompts_fetch.py`)
   - Reemplaza literales con bÃºsqueda de tokens

**InyecciÃ³n dinÃ¡mica**:
- Si usa tabla territorial: Agrega `MODULAR_TERRITORIAL_GUIDELINES`
- Si usa fuentes de financiamiento: Agrega `MODULAR_FUNDING_GUIDELINES`

**Join Optimization Note**:
Inyecta nota sobre mover filtros a clÃ¡usula `ON` para performance.

**Estado actualizado**: `state["sql_query"]` (nueva versiÃ³n)

**Siguiente**: Vuelve a `fetch_data`

---

### ETAPA 8: Post-Procesamiento ğŸ¨

#### `fetch_data (success) â†’ process_user_response`

**Archivo**: `nodes_postfetch.py`

**PropÃ³sito**: Convierte datos SQL en respuesta amigable para el ciudadano.

**Prompts**:
- Frontend: `user_response_frontend_prompt`
- WhatsApp: `user_response_whatsapp_prompt`
- No data: `user_response_norows_prompt`

**Proceso**:

1. **Parsing JSON**:
   - FunciÃ³n: `extract_json_rows()`
   - Maneja errores de formato

2. **ConstrucciÃ³n de Metadata**:
   - FunciÃ³n: `_build_columns_meta_from_rows()`
   - Detecta columnas monetarias
   - Genera labels legibles

3. **Formateo de Tabla**:
   - FunciÃ³n: `format_table_markdown()` (`modules/utils/markdown_utils.py`)
   - Aplica formato de moneda: `RD$ 1.234.567`
   - Genera Markdown table para frontend

4. **GeneraciÃ³n de Resumen**:
   - LLM genera respuesta estructurada (nuevo formato):
     ```json
     {
       "direct_answer": "Hay 1.209 proyectos de educaciÃ³n.",
       "technical_details": ["Se filtraron proyectos con sector = EDUCACIÃ“N"],
       "follow_up": "Â¿Le gustarÃ­a ver el detalle por regiÃ³n?",
       "monetary_columns": "valor_proyecto"
     }
     ```

5. **DetecciÃ³n de Limitaciones**:
   - Si `rowcount > limit`: Genera nota de aviso
   - Ejemplo: "Se muestran solo 100 resultados; pueden existir mÃ¡s."

6. **ConstrucciÃ³n de Notas Base**:
   - Warnings de gray zone
   - Uso de keyword regeneration
   - Filtros originales vs ajustados

**Estado actualizado**:
- `state["frontend_summary_raw"]`
- `state["frontend_table_markdown"]`
- `state["frontend_base_notes_raw"]`
- `state["frontend_rows_raw"]`
- `state["frontend_columns_meta"]`

---

### ETAPA 9: RevisiÃ³n Ciudadana ğŸ‘¥

#### `process_user_response â†’ evaluate_citizen_response`

**Archivo**: `nodes_postfetch.py`

**PropÃ³sito**: Aplica principios de transparencia y explicabilidad (UNESCO, RecomendaciÃ³n sobre Ã‰tica de IA, 2021).

**Proceso**:

1. **RecolecciÃ³n de SeÃ±ales**:
   - FunciÃ³n: `_collect_citizen_signals()`
   - Extrae 20+ indicadores del estado:
     - `rowcount`, `rows_displayed`
     - `coverage_warning`
     - `used_keyword_regenerate`
     - `missing_keywords`
     - `theme_keywords`, `theme_keywords_used`
     - etc.

2. **ValidaciÃ³n de Relevancia SemÃ¡ntica**:
   - FunciÃ³n: `_validate_semantic_relevance()`
   - Detecta falsos positivos (ej: "metro" en "Ã¡rea metropolitana" vs "sistema de transporte")
   - Usa keywords temÃ¡ticos del analyzer

3. **Filtrado de Filas Irrelevantes** (si es necesario):
   - Prompt: `row_relevance_evaluation_prompt` (`prompts_postfetch.py`)
   - EvalÃºa cada fila con LLM para relevancia semÃ¡ntica
   - Marca `all_rows_irrelevant` si todas son descartadas

4. **AplicaciÃ³n de Reglas HeurÃ­sticas**:
   - Itera sobre `CITIZEN_RULES` (`citizen_rules.py`)
   - EvalÃºa condiciones:
     ```python
     {
       "name": "coverage_warning",
       "conditions": {"coverage_warning": True, "rowcount_gt": 0},
       "effects": {
         "note": "coverage_warning",
         "actions": ["highlight_warning", "offer_increase_limit"]
       },
       "score_delta": -1
     }
     ```
   - Acumula notas y acciones

5. **Fragmentos HeurÃ­sticos**:
   - Genera mensajes ciudadanos basados en reglas aplicadas
   - Ejemplo: "Se muestran 100 de 500 registros."

6. **RevisiÃ³n con LLM** (opcional):
   - Prompt: `citizen_review_prompt` (`prompts_postfetch.py`)
   - Sintetiza todos los fragmentos en un mensaje cohesivo
   - Asigna tono: `empathetic`, `neutral`, `direct`

**Caso especial: Todas las filas irrelevantes**:
- Construye mensaje empÃ¡tico explicando el proceso
- Ofrece reintento con filtros ajustados
- Muestra muestra de lo que se encontrÃ³ (pero no es relevante)

**Estado actualizado**:
- `state["citizen_actions"]`: `["highlight_warning", "offer_increase_limit", ...]`
- `state["citizen_note"]`: Mensaje para el usuario
- `state["citizen_feedback"]`: Metadata de satisfacciÃ³n
- `state["frontend_rows_filtered"]`: Filas despuÃ©s de filtrado semÃ¡ntico
- `state["all_rows_irrelevant"]`: Flag crÃ­tico

---

### ETAPA 10: ComposiciÃ³n Final ğŸ

#### `evaluate_citizen_response â†’ compose_frontend_response`

**Archivo**: `nodes_postfetch.py`

**PropÃ³sito**: Ensambla todos los componentes en el payload final.

**Proceso**:

1. **ConstrucciÃ³n de Detalles TÃ©cnicos**:
   - FunciÃ³n: `_build_technical_detail_sections()`
   - Secciones:
     - **Filtros aplicados**
     - **Scope de datos** (paÃ­s, fechas)
     - **MetodologÃ­a** (aggregations, joins)
     - **Advertencias** (limitaciones de datos)
     - **Optimizaciones** (join pushdown, etc.)
   - Formato: Lista de strings para sidebar "Ver razonamiento"

2. **Reescritura de Resumen** (si es necesario):
   - Prompt: `citizen_summary_rewrite_prompt` (`prompts_postfetch.py`)
   - Limpia frases de metodologÃ­a del summary raw
   - Preserva los datos, solo mejora redacciÃ³n
   - Ejemplo:
     - Raw: "La consulta se enfocÃ³ en identificar proyectos de educaciÃ³n. Se encontraron 1.209."
     - Limpio: "Se encontraron 1.209 proyectos de educaciÃ³n."

3. **ConstrucciÃ³n de Payload "No Data"** (si `rowcount == 0`):
   - FunciÃ³n: `_build_no_data_payload()`
   - Incluye:
     - Mensaje principal explicativo
     - Hints prÃ¡cticos (verificar ortografÃ­a, ampliar bÃºsqueda)
     - Sugerencias basadas en catÃ¡logo de dimensiones
     - Filtros aplicados (para transparencia)

4. **Empaquetado en AIMessage**:
   - Formato JSON con `additional_kwargs`:
     ```json
     {
       "content": "Resumen ciudadano",
       "additional_kwargs": {
         "frontend_summary": "...",
         "frontend_table_markdown": "...",
         "frontend_base_notes": ["..."],
         "frontend_technical_details": ["..."],
         "frontend_show_table": true,
         "citizen_actions": ["..."],
         "no_data": {...}
       }
     }
     ```

**Estado actualizado**:
- `state["messages"]`: AIMessage final
- `state["frontend_summary"]`: VersiÃ³n mejorada
- `state["frontend_base_notes"]`: VersiÃ³n mejorada
- `state["frontend_technical_details"]`: Sidebar

---

#### `compose_frontend_response â†’ route_after_compose`

**Archivo**: `edges.py`  
**FunciÃ³n**: `route_after_compose()`

**DecisiÃ³n final**:

##### Caso 1: Reintento por Irrelevancia ğŸ”„

**CondiciÃ³n**:
- `all_rows_irrelevant == True`
- `irrelevant_retry_count == 0` (primer intento)

**AcciÃ³n**:
- Marca `state["irrelevant_retry_pending"] = True`
- Ajusta filtros para bÃºsqueda mÃ¡s amplia

**Ruta**: `regenerate_query` â†’ `fetch_data` (loop)

**LÃ­mite**: 1 reintento mÃ¡ximo

---

##### Caso 2: FinalizaciÃ³n âœ…

**CondiciÃ³n**: Cualquier otro caso

**Ruta**: **END**

**Payload devuelto al chat_service**:
```python
{
  "messages": [AIMessage(...)],
  "response_type": "data" | "no_data" | "clarification" | ...,
  "user_assistance": {...},  # Si hay clarificaciÃ³n pendiente
  "gray_zone_details": {...},  # Si hubo zona gris
  "citizen_actions": [...],
  "no_data_payload": {...}  # Si no hay datos
}
```

---

## ğŸ“ CatÃ¡logo de Nodos

### Pre-Fetch (Antes de SQL)

| Nodo | Archivo | PropÃ³sito |
|------|---------|-----------|
| `generate_complete_question_v2` | `nodes_prefetch.py` | Reescritura contextual |
| `inbox_classifier` | `nodes_prefetch.py` | ModeraciÃ³n + clasificaciÃ³n |
| `generate_question_summary` | `nodes_postfetch.py` | TÃ­tulo corto (8-13 palabras) |
| `retrieve_documents` | `nodes_prefetch.py` | Contexto y few-shots |
| `llm_analyzer` | `nodes_prefetch.py` | AnÃ¡lisis profundo (filtros, tablas) |
| `classify_question_complexity` | `nodes_fetch.py` | HeurÃ­stica simple/compleja |
| `llm_analyzer_2` | `nodes_prefetch.py` | Few-shots personalizados |

### SQL Generation

| Nodo | Archivo | PropÃ³sito |
|------|---------|-----------|
| `generate_sql_query` | `nodes_fetch.py` | One-shot (simple) |
| `generate_sql_candidates` | `nodes_fetch.py` | Multi-shot (compleja) |
| `select_best_sql_candidate` | `nodes_fetch.py` | Ranking por costo |
| `choose_sql_with_llm` | `nodes_fetch.py` | ElecciÃ³n final con LLM |

### Fetch & Error Handling

| Nodo | Archivo | PropÃ³sito |
|------|---------|-----------|
| `fetch_data` | `nodes_fetch.py` | EjecuciÃ³n de SQL |
| `regenerate_query` | `nodes_fetch.py` | CorrecciÃ³n de errores |
| `handle_gray_zone` | `nodes_fetch.py` | Manejo de incertidumbres |

### Post-Fetch

| Nodo | Archivo | PropÃ³sito |
|------|---------|-----------|
| `process_user_response` | `nodes_postfetch.py` | Formateo de respuesta |
| `evaluate_citizen_response` | `nodes_postfetch.py` | RevisiÃ³n ciudadana |
| `compose_frontend_response` | `nodes_postfetch.py` | Ensamblaje final |

### Exits (Salidas Tempranas)

| Nodo | Archivo | PropÃ³sito |
|------|---------|-----------|
| `moderation_reprompt` | `nodes_prefetch.py` | Bloqueo por seguridad |
| `definitions_lookup` | `nodes_prefetch.py` | Consulta de conceptos |
| `send_greeting` | `nodes_prefetch.py` | Saludos |
| `handle_irrelevant_question` | `nodes_prefetch.py` | Fuera de dominio |
| `send_support_response` | `nodes_prefetch.py` | Ayuda tÃ©cnica |
| `request_clarification` | `nodes.py` | Pedir aclaraciÃ³n |
| `prefetch_exit` | `nodes_exits.py` | Salida unificada |

---

## ğŸ› ï¸ MÃ³dulos de Helpers

### `helpers_estado.py`
**PropÃ³sito**: GestiÃ³n segura del estado compartido.

**Funciones principales**:
- `_get_*`: Lectura segura de campos del estado
- `_set_*`: Escritura con validaciÃ³n
- `_init_*`: InicializaciÃ³n de contenedores
- `_ensure_*`: Garantiza existencia de estructuras

**Ejemplo**:
```python
_ensure_sql_container(state)  # Crea state["sql"] = {...}
_set_sql_query(state, "SELECT ...")
sql = _get_sql_query(state)
```

### `helpers_texto.py`
**PropÃ³sito**: Procesamiento de texto.

**Funciones principales**:
- `_normalize_text()`: MinÃºsculas + sin acentos
- `_tokenize_question()`: Extrae tokens Ãºnicos
- `_fuzzy_match_from_catalog()`: Fuzzy matching con rapidfuzz
- `_sanitize_keyword_tokens()`: Limpia stopwords

**Constantes**:
- `STOPWORDS`: Lista de palabras irrelevantes
- `FRIENDLY_FILTER_NAMES`: Mapeo de nombres tÃ©cnicos a legibles

### `helpers_sql.py`
**PropÃ³sito**: ConstrucciÃ³n y manipulaciÃ³n de SQL.

**Funciones principales**:
- `_append_where_condition()`: Agrega clÃ¡usulas WHERE/AND
- `_apply_refined_filters_to_sql()`: Inyecta filtros refinados
- `_ensure_country_filter()`: Garantiza filtro de paÃ­s
- `_find_missing_filters()`: Detecta filtros ausentes
- `_score_sql_candidates()`: Ranking por EXPLAIN

**Constantes**:
- `BASE_PROJECT_TABLE = "stg_mapainv_proyectosaprobadosinv"`
- `TERRITORIAL_TABLES`, `FUNDING_TABLES`

### `helpers_respuesta.py`
**PropÃ³sito**: ConstrucciÃ³n de respuestas y asistencia.

**Funciones principales**:
- `_build_user_assistance()`: Payload de clarificaciÃ³n
- `_prepare_post_fetch_clarification()`: Opciones post-fetch
- `_filter_rows_and_columns_by_relevance()`: Filtrado inteligente
- `_collect_gray_zone_signals()`: Inferencia de zona gris
- `_rewrite_summary_with_llm()`: Mejora de resumen

---

## ğŸ§© Reglas Declarativas

### `citizen_rules.py`
Define condiciones que disparan feedback ciudadano.

**Ejemplo**:
```python
{
  "name": "coverage_warning",
  "conditions": {"coverage_warning": True, "rowcount_gt": 0},
  "effects": {
    "note": "coverage_warning",
    "actions": ["highlight_warning", "offer_increase_limit"]
  },
  "score_delta": -1
}
```

**Reglas incluidas**:
1. `coverage_warning`: Hay mÃ¡s resultados de los mostrados
2. `keyword_regenerate_notice`: Se usÃ³ bÃºsqueda parcial
3. `soft_missing_filters`: Filtros de baja confianza
4. `uncertainty_pending`: Dudas del analyzer
5. `missing_keywords_suggestion`: Keywords no encontrados
6. `duplicate_hint`: Posibles duplicados
7. `low_semantic_relevance`: Falsos positivos detectados

### `gray_zone_rules.py`
Define escenarios de "zona gris" (incertidumbre).

**Ejemplo**:
```python
{
  "name": "missing_dimension_from_soft_missing_filters",
  "reason": "MISSING_DIMENSION",
  "description": "El analyzer marcÃ³ filtros faltantes o de baja confianza.",
  "when": {"soft_missing_present": True}
}
```

**Razones incluidas**:
- `MISSING_DIMENSION`: DimensiÃ³n no disponible
- `UNSUPPORTED_METRIC`: MÃ©trica fuera del dataset
- `MISSING_ATTRIBUTE`: Atributo no en schema
- `NO_ROWS_FILTERED`: Filtros demasiado especÃ­ficos
- `FALLBACK_USED`: BÃºsqueda amplia sin resultados

---

## ğŸ¯ Flujos Especiales

### Cache Hit Flow
```
START â†’ generate_complete_question_v2 â†’ inbox_classifier
  â†’ route_after_inbox [cache hit]
  â†’ process_user_response (con cached_results)
  â†’ evaluate_citizen_response
  â†’ compose_frontend_response
  â†’ END
```

**Ventaja**: Salta todo el anÃ¡lisis y generaciÃ³n SQL.

### Definitions Lookup Flow
```
START â†’ generate_complete_question_v2 â†’ inbox_classifier
  â†’ route_after_inbox [is_definitions_lookup]
  â†’ definitions_lookup â†’ prefetch_exit â†’ END
```

**Ejemplo**: "Â¿QuÃ© es un proyecto de inversiÃ³n pÃºblica?"

### Moderation Block Flow
```
START â†’ generate_complete_question_v2 â†’ inbox_classifier
  â†’ route_after_inbox [recommended_action="block"]
  â†’ moderation_reprompt â†’ prefetch_exit â†’ END
```

### Zero Rows with Clarification Flow
```
... â†’ fetch_data [rowcount=0]
  â†’ handle_fetch_data_outcome
  â†’ request_clarification â†’ END
```

**Payload incluye**:
- Opciones interactivas (sectores, entidades)
- SinÃ³nimos sugeridos
- Filtros usados (transparencia)

### All Rows Irrelevant Retry Flow
```
... â†’ compose_frontend_response [all_rows_irrelevant=True, retry_count=0]
  â†’ route_after_compose
  â†’ regenerate_query [con filtros ajustados]
  â†’ fetch_data [reintento]
  â†’ ...
```

**LÃ­mite**: 1 reintento.

---

## ğŸ”§ Configuraciones Clave (settings)

### GeneraciÃ³n SQL
- `USE_COMPLEXITY_ROUTING`: Habilita ruta simple/compleja
- `max_sql_retries`: MÃ¡ximo de reintentos (default: 2)
- `sql_rows_limit`: LÃ­mite de filas por query (default: 100)
- `sql_rows_limit_max`: LÃ­mite absoluto (default: 1000)

### Analyzer
- `analyzer_filter_confidence_threshold`: Umbral para filtro hard (default: 0.8)
- `max_clarification_turns`: Turnos de aclaraciÃ³n (default: 2)

### Texto
- `min_text_filter_token_length`: Longitud mÃ­nima de token (default: 4)
- `max_refined_filter_tokens`: Tokens por filtro (default: 3)
- `text_filter_stoplist`: Lista personalizable de stopwords

### LLM
- `reasoning_seed`: Seed para reproducibilidad
- `reasoning_effort_sql`: Esfuerzo para SQL ("high")
- `reasoning_verbosity_sql`: Verbosidad ("low")

---

## ğŸ“Š Diagramas de Flujo

### Flujo Principal Simplificado

```
START
  â†“
generate_complete_question_v2
  â†“
inbox_classifier â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â†“                             â”‚
route_after_inbox               â”‚
  â”œâ”€ moderation â†’ END           â”‚
  â”œâ”€ definitions â†’ END          â”‚
  â”œâ”€ cache hit â†’ response       â”‚
  â”œâ”€ greeting â†’ END             â”‚
  â”œâ”€ irrelevant â†’ END           â”‚
  â””â”€ relevant â†“                 â”‚
     generate_question_summary  â”‚
       â†“                        â”‚
     retrieve_documents         â”‚
       â†“                        â”‚
     llm_analyzer               â”‚
       â†“                        â”‚
     route_after_analyzer       â”‚
       â”œâ”€ gray_zone â†’ END       â”‚
       â”œâ”€ clarification â†’ END   â”‚
       â””â”€ continue â†“            â”‚
          classify_complexity   â”‚
            â†“                   â”‚
          llm_analyzer_2        â”‚
            â†“                   â”‚
          route_complexity      â”‚
            â”œâ”€ SIMPLE           â”‚
            â”‚   â†“               â”‚
            â”‚ generate_sql_queryâ”‚
            â”‚   â†“               â”‚
            â””â”€ COMPLEX          â”‚
                â†“               â”‚
              generate_candidatesâ”‚
                â†“               â”‚
              select_best       â”‚
                â†“               â”‚
              choose_with_llm   â”‚
                â†“               â”‚
          [MERGE] â†“             â”‚
          fetch_data â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ (retry loop)
            â†“
          handle_outcome
            â”œâ”€ error â†’ regenerate â”€â”˜
            â”œâ”€ zero â†’ clarification â†’ END
            â””â”€ success â†“
               process_response
                 â†“
               evaluate_citizen
                 â†“
               compose_frontend
                 â†“
               route_after_compose
                 â”œâ”€ retry irrelevant â†’ regenerate
                 â””â”€ END
```

---

## ğŸš€ Optimizaciones Implementadas

### 1. Schema Filtering
**Antes**: Se enviaba todo el schema (3000+ tokens) al LLM.  
**DespuÃ©s**: Solo tablas relevantes (200-500 tokens).  
**Impacto**: 6x reducciÃ³n de tokens, generaciÃ³n mÃ¡s rÃ¡pida.

### 2. Lazy Loading de Dimensiones
**ImplementaciÃ³n**: `_get_dimensions_catalog()` con flag `lazy=True`  
**Beneficio**: Solo carga catÃ¡logo cuando se necesita.

### 3. Cache de Consultas
**Estrategia**:
- Cache reciente: < 5 minutos â†’ Salta todo
- Cache stale: 5-60 minutos â†’ Re-evalÃºa pero usa resultado si falla

### 4. Join Optimization
**TÃ©cnica**: Mover filtros a clÃ¡usula `ON` en lugar de `WHERE`  
**Ejemplo**:
```sql
-- Antes (lento)
FROM proyectos p
LEFT JOIN territorios t ON p.id = t.proyecto_id
WHERE t.provincia = 'Santo Domingo'

-- DespuÃ©s (rÃ¡pido)
FROM proyectos p
LEFT JOIN territorios t ON p.id = t.proyecto_id AND t.provincia = 'Santo Domingo'
```

### 5. Unique Lookup Bypass
**Caso**: Queries tipo "proyecto con id 123"  
**AcciÃ³n**: Genera SQL determinÃ­stico sin LLM  
**Beneficio**: Respuesta instantÃ¡nea.

### 6. Token Truncation
**FunciÃ³n**: `truncate_text()` (`helpers_texto.py`)  
**Uso**: Limita documentos recuperados para evitar overflow de contexto.

---

## ğŸ“ˆ MÃ©tricas y Monitoreo

### Logs Estructurados

Todos los nodos incluyen logs con prefijos:
- `FLOW â–¸`: Decisiones de flujo
- `SQL â–¸`: GeneraciÃ³n y ejecuciÃ³n SQL
- `ASSISTANCE â–¸`: Clarificaciones
- `CITIZEN â–¸`: RevisiÃ³n ciudadana

**Ejemplo**:
```
FLOW â–¸ RESPONSE using_live_sql
SQL â–¸ APPLY refined_filter id=abc123 column=nombre_proyecto
CITIZEN â–¸ POSTFETCH ready=True options=3 targets=['sector', 'entity']
```

### Trazabilidad

Cada nodo actualiza `state["lifecycle"]` con timestamps:
```python
state["lifecycle"] = {
  "analyzer_start": "2024-03-15T10:30:00",
  "analyzer_end": "2024-03-15T10:30:05",
  "sql_generation_start": "...",
  ...
}
```

---

## ğŸ”’ Seguridad y Privacidad

### ModeraciÃ³n de PII
**Nodo**: `inbox_classifier`  
**Detecta**:
- Nombres completos
- NÃºmeros de identificaciÃ³n (cÃ©dulas, pasaportes)
- Direcciones, telÃ©fonos, emails
- Datos financieros personales

**AcciÃ³n**: `reprompt` o `block` segÃºn gravedad.

### SQL Injection Prevention
**TÃ©cnicas**:
1. **ParametrizaciÃ³n**: Todos los valores user-provided usan prepared statements
2. **SanitizaciÃ³n**: `safe_value = value.replace("'", "''")`
3. **ValidaciÃ³n de schema**: Solo columnas existentes
4. **Timeout**: 30s mÃ¡ximo por query

### SanitizaciÃ³n de Respuestas
**Prompt instruction**:
> "If the user's text contains potentially sensitive terms, do not repeat them verbatim; paraphrase or replace with [redacted term]."

---

## ğŸ§ª Testing y ValidaciÃ³n

### Few-Shot Quality
**Proceso**:
- RecuperaciÃ³n vectorial desde repositorio de ejemplos
- Re-ranking por similitud semÃ¡ntica
- ValidaciÃ³n de formato (NL â†’ SQL correcta)

### SQL Validation
**Pre-ejecuciÃ³n**:
- EXPLAIN para estimar costo
- DetecciÃ³n de queries prohibidas (DELETE, DROP, etc.)

**Post-ejecuciÃ³n**:
- SerializaciÃ³n JSON exitosa
- Rowcount vs expected

### Citizen Review Test Cases
Casos cubiertos por reglas:
- Coverage warning con 1000+ rows
- Keyword regeneration usado
- Todas las filas irrelevantes detectadas
- Duplicados potenciales
- Falsos positivos semÃ¡nticos

---

## ğŸ“š Referencias y Principios

### Transparencia (UNESCO)
> "Los actores de la IA deberÃ­an promover la transparencia permitiendo el rastreo y la explicaciÃ³n de los sistemas de IA."

**ImplementaciÃ³n**:
- Sidebar "Ver razonamiento" con detalles tÃ©cnicos
- Citizen review con feedback explÃ­cito
- Notas de limitaciones y warnings

### Explicabilidad
**Ejemplos**:
- "Se muestran 100 de 500 resultados" (coverage)
- "Se usÃ³ bÃºsqueda parcial con tokens: [metro, santo, domingo]" (keyword)
- "Se encontraron proyectos de infraestructura vial, pero no de metro" (irrelevancia)

---

## ğŸ”„ Mantenimiento y EvoluciÃ³n

### Agregar Nuevos Nodos
1. Definir funciÃ³n en `nodes_*.py`
2. Agregar decorador `@trace_node`
3. Actualizar `state.py` si es necesario
4. Registrar en `graph.py`:
   ```python
   workflow.add_node("nuevo_nodo", nuevo_nodo)
   workflow.add_edge("nodo_anterior", "nuevo_nodo")
   ```

### Agregar Nuevas Reglas Ciudadanas
1. Editar `citizen_rules.py`:
   ```python
   {
     "name": "nueva_regla",
     "conditions": {"flag_custom": True},
     "effects": {
       "note": "mensaje_custom",
       "actions": ["accion_nueva"]
     },
     "score_delta": -1
   }
   ```
2. Actualizar `_collect_citizen_signals()` con nuevos flags

### Actualizar Prompts
**UbicaciÃ³n**: `prompts_*.py`  
**Versionado**: Los prompts tienen comentarios de changelog  
**Testing**: Validar con ejemplos histÃ³ricos antes de deploy

---

## ğŸ“ Glosario

- **AgentState**: Estructura de datos compartida entre nodos (TypedDict)
- **Analyzer**: Nodo que extrae metadata estructurada de la pregunta
- **Citizen Review**: Proceso de validaciÃ³n ciudadana post-respuesta
- **Few-Shot**: Ejemplo de NLâ†’SQL usado como contexto para el LLM
- **Gray Zone**: Escenario de incertidumbre donde no se puede proceder
- **NL2SQL**: Natural Language to SQL (generaciÃ³n de SQL desde lenguaje natural)
- **Refined Filters**: Filtros mejorados con tokens, acrÃ³nimos, fuzzy matching
- **Rerank**: Re-ordenamiento de resultados de bÃºsqueda por relevancia
- **Schema Filtering**: ReducciÃ³n del schema a solo tablas relevantes

---

## ğŸ“ Contacto y Soporte

Para preguntas sobre esta documentaciÃ³n:
- **Repositorio**: `ChatBot_v2`
- **Directorio**: `app/modules/graph/`
- **DocumentaciÃ³n adicional**: `docs/`

---

**Ãšltima actualizaciÃ³n**: 2025-11-29  
**Generado automÃ¡ticamente por**: Agente de DocumentaciÃ³n  
**VersiÃ³n del grafo**: 2025-11-25
