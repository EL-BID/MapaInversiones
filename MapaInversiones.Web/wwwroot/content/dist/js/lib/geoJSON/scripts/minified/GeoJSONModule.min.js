(function () { var a = new Microsoft.Maps.Polygon; if (!a.getRings) { Microsoft.Maps.loadModule("Microsoft.Maps.AdvancedShapes") } })(); Microsoft.Maps.Pushpin.prototype.Metadata = null; Microsoft.Maps.Polyline.prototype.Metadata = null; Microsoft.Maps.Polygon.prototype.Metadata = null; Microsoft.Maps.EntityCollection.prototype.Metadata = null; var GeoJSONModule = function () { function d(c) { if (a != null) { var d = e(c); var f; if (b != null && b.length > 0) { f = Microsoft.Maps.LocationRect.fromLocations(b) } else { f = new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(0, 0), 360, 180) } a(d, f) } } function e(a) { var b = null; switch (a.type) { case "FeatureCollection": b = n(a); break; case "Feature": b = m(a); break; case "Point": var c = f(a); b = o(c); if (a.properties) b.Metadata = a.properties; break; case "LineString": b = g(a); break; case "Polygon": b = h(a); break; case "MultiPoint": b = new Microsoft.Maps.EntityCollection; $(i(a)).each(function (a, c) { b.push(o(c)) }); break; case "MultiLineString": b = new Microsoft.Maps.EntityCollection; $(j(a)).each(function (a, c) { b.push(c) }); break; case "MultiPolygon": b = new Microsoft.Maps.EntityCollection; $(k(a)).each(function (a, c) { b.push(c) }); break; case "GeometryCollection": b = l(a); break; default: } return b } function f(a) { var c = new Microsoft.Maps.Location(a.coordinates[1], a.coordinates[0]); b.push(c); return c } function g(a) { var b = new Microsoft.Maps.Polyline(i(a), c.polylineOptions); if (a.properties) b.Metadata = a.properties; return b } function h(a) { var b = []; $(a.coordinates).each(function (a, c) { b.push(i({ coordinates: c })) }); var d = new Microsoft.Maps.Polygon(b, c.polygonOptions); if (a.properties) d.Metadata = a.properties; return d } function i(a) { var b = []; $(a.coordinates).each(function (a, c) { b.push(f({ coordinates: c })) }); if (a.properties) b.Metadata = a.properties; return b } function j(a) { var b = []; $(a.coordinates).each(function (a, c) { b.push(g({ coordinates: c })) }); if (a.properties) b.Metadata = a.properties; return b } function k(a) { var b = []; $(a.coordinates).each(function (a, c) { $(c).each(function (a, c) { b.push(h({ coordinates: c })) }) }); if (a.properties) b.Metadata = a.properties; return b } function l(a) { var b = new Microsoft.Maps.EntityCollection; $(a.geometries).each(function (a, c) { var d = m({ geometry: c }); if (d) b.push(d) }); if (a.properties) b.Metadata = a.properties; return b } function m(a) { var b; var c = a.geometry; switch (c.type) { case "Point": var d = f(c); b = o(d); if (c.properties) b.Metadata = c.properties; break; case "LineString": b = g(c); break; case "Polygon": b = h(c); break; case "MultiPoint": b = new Microsoft.Maps.EntityCollection; $(i(c)).each(function (a, c) { b.push(o(c)) }); break; case "MultiLineString": b = new Microsoft.Maps.EntityCollection; $(j(c)).each(function (a, c) { b.push(c) }); break; case "MultiPolygon": b = new Microsoft.Maps.EntityCollection; $(k(c)).each(function (a, c) { b.push(c) }); break; default: } if (a.properties) b.Metadata = a.properties; return b } function n(a) { var b = new Microsoft.Maps.EntityCollection; $(a.features).each(function (a, c) { b.push(m(c)) }); return b } function o(a) { return new Microsoft.Maps.Pushpin(a, c.pushpinOptions) } var a = null, b = [], c = { pushpinOptions: null, polylineOptions: null, polygonOptions: null }; this.ImportGeoJSON = function (b, e, f) { a = e; if (f != null) { for (attrname in f) { c[attrname] = f[attrname] } } $.getJSON(b, function (a) { d(a) }) } }; (function () { var a = new Microsoft.Maps.Polygon; if (!a.getRings) { Microsoft.Maps.loadModule("Microsoft.Maps.AdvancedShapes", { callback: function () { Microsoft.Maps.moduleLoaded("GeoJSONModule") } }) } else { Microsoft.Maps.moduleLoaded("GeoJSONModule") } })()